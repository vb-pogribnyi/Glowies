#version 460
#extension GL_GOOGLE_include_directive : enable         // To be able to use #include
#extension GL_EXT_ray_tracing : require                 // This is about ray tracing
#extension GL_KHR_shader_subgroup_basic : require       // Special extensions to debug groups, warps, SM, ...
#extension GL_EXT_scalar_block_layout : enable          // Align structure layout to scalar
#extension GL_EXT_nonuniform_qualifier : enable         // To access unsized descriptor arrays
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters
#extension GL_EXT_scalar_block_layout : enable          // Usage of 'scalar' block layout

#extension GL_NV_shader_sm_builtins : require     // Debug - gl_WarpIDNV, gl_SMIDNV
#extension GL_ARB_gpu_shader_int64 : enable       // Debug - heatmap value
#extension GL_EXT_shader_realtime_clock : enable  // Debug - heatmap timing

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable

#include "raycommon.glsl"
#include "random.glsl"
#include "host_device.h"

layout(location = 0) rayPayloadEXT hitPayload prd;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(set = 1, binding = eObjDescs, scalar) buffer ObjDesc_ { ObjDesc i[]; } objDesc;
layout(set = 1, binding = eGlobals) uniform _GlobalUniforms { GlobalUniforms uni; };
layout(push_constant) uniform _PushConstantRay
{
  PushConstantRay rtxState;
};

layout(buffer_reference, scalar) buffer Vertices {Vertex v[]; }; // Positions of an object
layout(buffer_reference, scalar) buffer Indices {ivec3 i[]; }; // Triangle indices
layout(buffer_reference, scalar) buffer Materials {WaveFrontMaterial m[]; }; // Array of all materials on an object
layout(buffer_reference, scalar) buffer MatIndices {int i[]; }; // Material ID for each triangle

#include "pathtrace.glsl"


// utility for temperature
float fade(float low, float high, float value)
{
  float mid   = (low + high) * 0.5;
  float range = (high - low) * 0.5;
  float x     = 1.0 - clamp(abs(mid - value) / range, 0.0, 1.0);
  return smoothstep(0.0, 1.0, x);
}


// Return a cold-hot color based on intensity [0-1]
vec3 temperature(float intensity)
{
  const vec3 blue   = vec3(0.0, 0.0, 1.0);
  const vec3 cyan   = vec3(0.0, 1.0, 1.0);
  const vec3 green  = vec3(0.0, 1.0, 0.0);
  const vec3 yellow = vec3(1.0, 1.0, 0.0);
  const vec3 red    = vec3(1.0, 0.0, 0.0);

  vec3 color = (fade(-0.25, 0.25, intensity) * blue    //
                + fade(0.0, 0.5, intensity) * cyan     //
                + fade(0.25, 0.75, intensity) * green  //
                + fade(0.5, 1.0, intensity) * yellow   //
                + smoothstep(0.75, 1.0, intensity) * red);
  return color;
}

void main() 
{

  uint64_t start = clockRealtimeEXT();  // Debug - Heatmap

  ivec2 imageRes    = rtxState.size;
  ivec2 imageCoords = ivec2(gl_LaunchIDEXT.xy);

  // Initialize the random number
  prd.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, rtxState.frame);



  vec3 pixelColor = vec3(0);
  for(int smpl = 0; smpl < rtxState.maxSamples; ++smpl)
  {
    pixelColor += samplePixel(imageCoords, imageRes);  // See pathtrace.glsl
  }

  pixelColor /= rtxState.maxSamples;

  // Debug - Heatmap
  if(rtxState.debugging_mode == eHeatmap)
  {
    uint64_t end  = clockRealtimeEXT();
    float    low  = rtxState.minHeatmap;
    float    high = rtxState.maxHeatmap;
    float    val  = clamp((float(end - start) - low) / (high - low), 0.0, 1.0);
    pixelColor    = temperature(val);
  }

  // Do accumulation over time
  if(rtxState.frame > 0)
  {
    vec3 old_color  = imageLoad(image, imageCoords).xyz;
    vec3 new_result = mix(old_color, pixelColor, 1.0f / float(rtxState.frame + 1));

    imageStore(image, imageCoords, vec4(new_result, 1.f));
  }
  else
  {
    // First frame, replace the value in the buffer
    imageStore(image, imageCoords, vec4(pixelColor, 1.f));
  }
}
