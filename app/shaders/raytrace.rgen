#version 460
#extension GL_GOOGLE_include_directive : enable         // To be able to use #include
#extension GL_EXT_ray_tracing : require                 // This is about ray tracing
#extension GL_KHR_shader_subgroup_basic : require       // Special extensions to debug groups, warps, SM, ...
#extension GL_EXT_scalar_block_layout : enable          // Align structure layout to scalar
#extension GL_EXT_nonuniform_qualifier : enable         // To access unsized descriptor arrays
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters
#extension GL_EXT_scalar_block_layout : enable          // Usage of 'scalar' block layout

#extension GL_NV_shader_sm_builtins : require     // Debug - gl_WarpIDNV, gl_SMIDNV
#extension GL_ARB_gpu_shader_int64 : enable       // Debug - heatmap value
#extension GL_EXT_shader_realtime_clock : enable  // Debug - heatmap timing

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable

#include "raycommon.glsl"
#include "random.glsl"
#include "host_device.h"

layout(location = 0) rayPayloadEXT hitPayloadSimpli prd;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(set = 1, binding = eGlobals) uniform _GlobalUniforms { GlobalUniforms uni; };
layout(push_constant) uniform _PushConstantRay
{
  PushConstantRay rtxState;
};



void main() 
{
  ivec2 imageRes    = rtxState.size;
  ivec2 imageCoords = ivec2(gl_LaunchIDEXT.xy);
  uint64_t start = clockRealtimeEXT();  // Debug - Heatmap

  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2       d           = inUV * 2.0 - 1.0;

  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);
  vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);

  uint rayFlags = gl_RayFlagsNoneEXT;
  prd.hitValue = vec3(0);
  prd.depth = 0;

  traceRayEXT(topLevelAS,   // acceleration structure
              rayFlags,     // rayFlags
              0xFF,         // cullMask
              0,            // sbtRecordOffset
              0,            // sbtRecordStride
              0,            // missIndex
              origin.xyz,       // ray origin
              0.0,          // ray min range
              direction.xyz,    // ray direction
              INFINITY,     // ray max range
              0             // payload (location = 0)
  );

  vec3 pixelColor = prd.hitValue;

  // Debug - Heatmap
  if(rtxState.debugging_mode == eHeatmap)
  {
    uint64_t end  = clockRealtimeEXT();
    float    low  = rtxState.minHeatmap;
    float    high = rtxState.maxHeatmap;
    float    val  = clamp((float(end - start) - low) / (high - low), 0.0, 1.0);
    pixelColor    = temperature(val);
  }

  imageStore(image, imageCoords, vec4(pixelColor, 1.f));
}
