#version 460
#extension GL_GOOGLE_include_directive : enable         // To be able to use #include
#extension GL_EXT_ray_tracing : require                 // This is about ray tracing
#extension GL_EXT_ray_query : enable
#extension GL_KHR_shader_subgroup_basic : require       // Special extensions to debug groups, warps, SM, ...
#extension GL_EXT_scalar_block_layout : enable          // Align structure layout to scalar
#extension GL_EXT_nonuniform_qualifier : enable         // To access unsized descriptor arrays
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters
#extension GL_EXT_scalar_block_layout : enable          // Usage of 'scalar' block layout

#extension GL_NV_shader_sm_builtins : require     // Debug - gl_WarpIDNV, gl_SMIDNV
#extension GL_ARB_gpu_shader_int64 : enable       // Debug - heatmap value
#extension GL_EXT_shader_realtime_clock : enable  // Debug - heatmap timing

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable

#include "raycommon.glsl"
#include "random.glsl"
#include "host_device.h"

layout(location = 0) rayPayloadEXT hitPayloadSimpli prd;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(set = 1, binding = eGlobals) uniform _GlobalUniforms { GlobalUniforms uni; };
layout(push_constant) uniform _PushConstantRay
{
  PushConstantRay rtxState;
};
layout(set = 1, binding = eObjDescs, scalar) buffer ObjDesc_ { ObjDesc i[]; } objDesc;
layout(buffer_reference, scalar) buffer Vertices {Vertex v[]; }; // Positions of an object
layout(buffer_reference, scalar) buffer Indices {ivec3 i[]; }; // Triangle indices
layout(buffer_reference, scalar) buffer Materials {WaveFrontMaterial m[]; }; // Array of all materials on an object
layout(buffer_reference, scalar) buffer MatIndices {int i[]; }; // Material ID for each triangle


vec3 computeDiffuse(WaveFrontMaterial mat, vec3 lightDir, vec3 normal)
{
  // Lambertian
  float dotNL = max(dot(normal, lightDir), 0.0);
  vec3  c     = mat.diffuse * dotNL;
  if(mat.illum >= 1)
    c += 0.12 * mat.diffuse;    // Ambient color
  return c;
}

vec3 computeSpecular(WaveFrontMaterial mat, vec3 viewDir, vec3 lightDir, vec3 normal)
{
  if(mat.illum < 2)
    return vec3(0);

  // Compute specular only if not in shadow
  const float kPi        = 3.14159265;
  const float kShininess = max(mat.shininess, 4.0);

  // Specular
  const float kEnergyConservation = (2.0 + kShininess) / (2.0 * kPi);
  vec3        V                   = normalize(-viewDir);
  vec3        R                   = reflect(-lightDir, normal);
  float       specular            = kEnergyConservation * pow(max(dot(V, R), 0.0), kShininess);

  return vec3(mat.specular * specular);
}

vec3 getColor(WaveFrontMaterial mat, vec3 L, rayQueryEXT rayQuery, vec3 worldNrm) {
  float attenuation = 1;
  vec3  specular    = vec3(0);
  vec3 diffuse = computeDiffuse(mat, L, worldNrm);
  //////////////////////////////////////
  // Transparent material
  //////////////////////////////////////

  if (mat.transmittance.x > 0) {  
    float tMin   = 0.001;
    float tMax   = INFINITY;
    // vec3  origin = rayQueryGetWorldRayOriginEXT(rayQuery) + rayQueryGetWorldRayDirectionEXT(rayQuery) * gl_HitTEXT;
    float eta = 1 / 1.4;
    vec3 nrm = worldNrm;
    if (dot(worldNrm, rayQueryGetWorldRayDirectionEXT(rayQuery)) > 0) {
      eta = 1 / eta;
      nrm = -1 * nrm;
    }
    vec3  rayDir = refract(rayQueryGetWorldRayDirectionEXT(rayQuery), nrm, eta);
    if (length(rayDir) == 0) rayDir = reflect(rayQueryGetWorldRayDirectionEXT(rayQuery), nrm);
    uint  flags  = gl_RayFlagsNoneEXT;
/*
    traceRayEXT(topLevelAS,  // acceleration structure
                flags,       // rayFlags
                0xFF,        // cullMask
                0,           // sbtRecordOffset
                0,           // sbtRecordStride
                0,           // missIndex
                origin,      // ray origin
                tMin,        // ray min range
                rayDir,      // ray direction
                tMax,        // ray max range
                0            // payload (location = 0)
    );
*/
    return vec3(0, 1, 0);
  }

  // Tracing shadow ray only if the light is visible from the surface
  if(dot(worldNrm, L) > 0)
  {
    float tMin   = 0.001;
    float tMax   = INFINITY;
    vec3  origin = rayQueryGetWorldRayOriginEXT(rayQuery) + rayQueryGetWorldRayDirectionEXT(rayQuery) * rayQueryGetIntersectionTEXT(rayQuery, true);
    vec3  rayDir = L;
    uint  flags  = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
    prd.isShadowed   = true;
    traceRayEXT(topLevelAS,  // acceleration structure
                flags,       // rayFlags
                0xFF,        // cullMask
                0,           // sbtRecordOffset
                0,           // sbtRecordStride
                0,           // missIndex
                origin,      // ray origin
                tMin,        // ray min range
                rayDir,      // ray direction
                tMax,        // ray max range
                0            // payload (location = 0)
    );

    if(prd.isShadowed)
    {
      attenuation = 0.3;
    }
    else
    {
      // Specular
      specular = computeSpecular(mat, rayQueryGetWorldRayDirectionEXT(rayQuery), L, worldNrm);
    }
  }

  return vec3(attenuation * (diffuse + specular));
}

void main() 
{
  ivec2 imageRes    = rtxState.size;
  ivec2 imageCoords = ivec2(gl_LaunchIDEXT.xy);
  uint64_t start = clockRealtimeEXT();  // Debug - Heatmap

  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2       d           = inUV * 2.0 - 1.0;

  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);
  vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);

  uint rayFlags = gl_RayFlagsNoneEXT;
  prd.hitValue = vec3(0);
  prd.depth = 0;
  prd.isSkipAll = false;

  vec3 pixelColor = vec3(0, 0, 0);


  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery,     //
                        topLevelAS,   // acceleration structure
                        rayFlags,     // rayFlags
                        0xFF,         // cullMask
                        origin.xyz,     // ray origin
                        0.0,          // ray min range
                        direction.xyz,  // ray direction
                        INFINITY);    // ray max range
  
  // Start traversal: return false if traversal is complete
  while(rayQueryProceedEXT(rayQuery))
  {
    if(rayQueryGetIntersectionTypeEXT(rayQuery, false) == gl_RayQueryCandidateIntersectionTriangleEXT)
    {
/*
      // Object data
      ObjDesc    objResource = objDesc.i[rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true)];
      MatIndices matIndices  = MatIndices(objResource.materialIndexAddress);
      Materials  materials   = Materials(objResource.materialAddress);
      Indices    indices     = Indices(objResource.indexAddress);
      Vertices   vertices    = Vertices(objResource.vertexAddress);

      // Indices of the triangle
      ivec3 ind = indices.i[rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true)];

      // Vertex of the triangle
      Vertex v0 = vertices.v[ind.x];
      Vertex v1 = vertices.v[ind.y];
      Vertex v2 = vertices.v[ind.z];
      vec2       bary         = rayQueryGetIntersectionBarycentricsEXT(rayQuery, false);
      const vec3 barycentrics = vec3(1.0 - bary.x - bary.y, bary.x, bary.y);

      // Computing the coordinates of the hit position
      const vec3 pos      = v0.pos * barycentrics.x + v1.pos * barycentrics.y + v2.pos * barycentrics.z;
      const vec3 worldPos = vec3(rayQueryGetIntersectionObjectToWorldEXT(rayQuery, true) * vec4(pos, 1.0));  // Transforming the position to world space

      // Computing the normal at hit position
      const vec3 nrm      = v0.nrm * barycentrics.x + v1.nrm * barycentrics.y + v2.nrm * barycentrics.z;
      const vec3 worldNrm = normalize(vec3(nrm * rayQueryGetIntersectionWorldToObjectEXT(rayQuery, true)));  // Transforming the normal to world space

      int               matIdx = matIndices.i[rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true)];
      WaveFrontMaterial mat    = materials.m[matIdx];

      pixelColor = mat.diffuse.xyz;
*/

      rayQueryConfirmIntersectionEXT(rayQuery);  // The hit was opaque
    }
  }


  bool hit = (rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT);
  if(hit)
  {

      // Object data
      ObjDesc    objResource = objDesc.i[rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true)];
      MatIndices matIndices  = MatIndices(objResource.materialIndexAddress);
      Materials  materials   = Materials(objResource.materialAddress);
      Indices    indices     = Indices(objResource.indexAddress);
      Vertices   vertices    = Vertices(objResource.vertexAddress);

      // Indices of the triangle
      ivec3 ind = indices.i[rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true)];

      // Vertex of the triangle
      Vertex v0 = vertices.v[ind.x];
      Vertex v1 = vertices.v[ind.y];
      Vertex v2 = vertices.v[ind.z];
      vec2       bary         = rayQueryGetIntersectionBarycentricsEXT(rayQuery, false);
      const vec3 barycentrics = vec3(1.0 - bary.x - bary.y, bary.x, bary.y);

      // Computing the coordinates of the hit position
      const vec3 pos      = v0.pos * barycentrics.x + v1.pos * barycentrics.y + v2.pos * barycentrics.z;
      const vec3 worldPos = vec3(rayQueryGetIntersectionObjectToWorldEXT(rayQuery, true) * vec4(pos, 1.0));  // Transforming the position to world space

      // Computing the normal at hit position
      const vec3 nrm      = v0.nrm * barycentrics.x + v1.nrm * barycentrics.y + v2.nrm * barycentrics.z;
      const vec3 worldNrm = normalize(vec3(nrm * rayQueryGetIntersectionWorldToObjectEXT(rayQuery, true)));  // Transforming the normal to world space

      int               matIdx = matIndices.i[rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true)];
      WaveFrontMaterial mat    = materials.m[matIdx];

      pixelColor = getColor(mat, normalize(vec3(1, 0.7, 0.2)), rayQuery, worldNrm);
    /*
    prd.hitT                = rayQueryGetIntersectionTEXT(rayQuery, true);
    prd.primitiveID         = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
    prd.instanceID          = rayQueryGetIntersectionInstanceIdEXT(rayQuery, true);
    prd.instanceCustomIndex = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
    prd.baryCoord           = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
    prd.objectToWorld       = rayQueryGetIntersectionObjectToWorldEXT(rayQuery, true);
    prd.worldToObject       = rayQueryGetIntersectionWorldToObjectEXT(rayQuery, true);
    */
  }
/*
  traceRayEXT(topLevelAS,   // acceleration structure
              rayFlags,     // rayFlags
              0xFF,         // cullMask
              0,            // sbtRecordOffset
              0,            // sbtRecordStride
              0,            // missIndex
              origin.xyz,       // ray origin
              0.0,          // ray min range
              direction.xyz,    // ray direction
              INFINITY,     // ray max range
              0             // payload (location = 0)
  );

  vec3 pixelColor = prd.hitValue;
*/
  // Debug - Heatmap
  if(rtxState.debugging_mode == eHeatmap)
  {
    uint64_t end  = clockRealtimeEXT();
    float    low  = rtxState.minHeatmap;
    float    high = rtxState.maxHeatmap;
    float    val  = clamp((float(end - start) - low) / (high - low), 0.0, 1.0);
    pixelColor    = temperature(val);
  }

  imageStore(image, imageCoords, vec4(pixelColor, 1.f));
}
